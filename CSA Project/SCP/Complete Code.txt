
// make reading asynchronous and write synchronous


// COMPLETE PROCESSOR


module processor(clk,rst);
  input clk,rst;
  //pc stuff
  wire [31:0] CPC,CPC_4;
  wire [31:0] jump_address;
  //decoder stuff
  wire [31:0] instruction;
  wire [5:0] opcode;
  wire [4:0] Rs,Rt,Rd,shamt;
  wire [5:0] funct;
  wire [31:0] constant;
  //control stuff
  wire RegDst,Jump,Branch,MemRead,MemtoReg,MemWrite,ALUSrc,RegWrite,Zero;
  wire [1:0] ALUOp;
  //ALU control stuff
  wire [3:0] ALUopcode;
  //Register file
  wire [31:0] rwrite_data;
  wire [31:0] Areg,Breg;
  //ALU
  wire [31:0] ALU_out;
  //Data Memory
  // everything defined
  
  // initial conditions
  assign rst = 1;
  
  ProgramCounter pc_obj(Jump,Branch,Zero,constant,jump_address,clk,rst,CPC,CPC_4);
  ROM rom_obj(CPC,instruction);
  Decoder decoder_obj(CPC_4,instruction,opcode,Rs,Rt,Rd,shamt,funct,constant,jump_address);
  Control control_obj(opcode,RegDst,Jump,Branch,MemRead,MemtoReg,ALUOp,MemWrite,ALUSrc,RegWrite);
  ALUControl alu_control_obj(funct,ALUOp,ALUopcode);
  
  // At this point all control signals would be known and all other instruction fields would also be known
  
  //if lw
  RegFile regfile_obj(clk,ALUSrc,RegDst,RegWrite,Rs,Rt,Rd,rwrite_data,constant,Areg,Breg);
  ALU alu_obj(ALUopcode,Areg,Breg,shamt,ALU_out,Zero);
  RAM ram_obj1(clk,MemtoReg,MemRead,MemWrite,ALU_out,Breg,rwrite_data);
  
endmodule

 // PC DESIGN:
 // NOTE :
 // It will only work when we will reset PC first ( raise rst to 1 and then assign it to 0 )
module ProgramCounter(Jump,Branch,Zero,constant,jump_address,clk,rst,CPC,CPC_4);
  input Jump,Branch,Zero,clk,rst;
  input [31:0] jump_address,constant;
  wire [31:0] branch_address,NPC,w;
  output reg [31:0] CPC;
  output [31:0] CPC_4;
  assign branch_address = (constant) + CPC_4;
  assign w = (Branch&Zero)? branch_address : CPC_4;
  assign NPC = (Jump)? jump_address : w;
  
  always@(posedge clk or posedge rst)
    begin
      if (rst == 1)                  //value of current PC will reset when rst signal will be 1 //
        CPC <= 0;  
      else
        CPC <= NPC;  
    end
 assign CPC_4 = CPC + 1;
endmodule

// ROM DESIGN:
module ROM(instr_address,instruction);
  input [31:0] instr_address;
  output reg [31:0] instruction;
  reg [31:0]instrmem[9:0];                  //base line of code for the creation of ROM//
  initial                                   //declaration of INSTRUCTION MEMORY done at start//
  begin
    //                opcode rs    rt    offset
    instrmem[0]= 32'b 000001_00000_00000_0000000000000000;              //opcode for lw
    instrmem[1]= 32'b 000001_00000_00001_0000000000000001;
    instrmem[2]= 32'b 000001_00000_00010_0000000000000010;
    //                opcode rs    rt    rd    shamt funct
    instrmem[3]= 32'b 000000_00010_00000_00000_00000_100000;            //opcode for R type ( funct field == add )
    //                opcode rs    rt    constant
    instrmem[4]= 32'b 000011_00000_00001_0000000000000001;              //opcode for beq
    //                opcode jump_address
    instrmem[5]= 32'b 000100_00000000000000000000000011;                //opcode for jump
        //                opcode rs    rt    offset
    instrmem[6]= 32'b 000010_00000_00000_0000000000000011;              //opcode for sw
    //last line of code (this will execute an infinite loop
    //                opcode jump_address
    instrmem[7]= 32'b 000100_00000000000000000000000111;                //opcode for jump
  end

  // chose instruction
  always@(*)
  begin
    instruction <= instrmem[instr_address];
  end

endmodule

// DECODER DESIGN
module Decoder(CPC_4,instruction,opcode,Rs,Rt,Rd,shamt,funct,constant,jump_address);
  input[31:0] instruction,CPC_4;
  // Instruction Components
  output[5:0] opcode;
  output reg[4:0] Rs,Rt,Rd,shamt;
  output reg[5:0] funct;
  output reg[31:0] constant;             // 32 bit after sign extension
  output reg[31:0] jump_address;         // 32 bit after shift left and concatenation with CPC_4
  // Instruction Slicing //
  assign opcode = instruction[31:26];    // first 6 bits (MSB) of instruction at (CPC) index are opcode
  always@(*)
    begin
      //R type instruction slicing
      if (opcode == 6'b 000000)                         
        begin
          Rs <= instruction[25:21];
          Rt <= instruction[20:16];
          Rd <= instruction[15:11];
          shamt <= instruction[10:6];
          funct <= instruction[5:0];
      //assigning all other to x (dont care)
          constant <= 32'b x;
          jump_address <= 32'b x;
        end
      //I type instruction slicing (beq)(lw)(sw)
      else if ((opcode == 6'b 000001) | (opcode == 6'b 000010) | (opcode == 6'b 000011))      
        begin
          Rs <= instruction[25:21];
          Rt <= instruction[20:16];
          // MSB to be copied in constant to sign extend it
          if(instruction[15] == 1)
            begin
              constant <= { 16'b 1, instruction[15:0]};
            end  
          else if (instruction[15] == 0)
            begin
              constant <= { 16'b 0, instruction[15:0]};
            end
          // multiplication by 4 after sign extension ( shift left 2 times )
          // constant <= constant << 2;  
          //assigning all other to x (dont care)
          Rd = 5'b x;
          shamt = 5'b x;
          funct = 6'b x;
          jump_address = 32'b x;
        end

      //J type instruction slicing
      else if (opcode == 4)                          
        begin 
          if (instruction[25] == 1)
          begin 
            jump_address <= {CPC_4[31:28],1'b1,1'b1,instruction[25:0] };
          end
        else if (instruction[25] == 0)
          begin
            jump_address <= { CPC_4[31:28],1'b0,1'b0,instruction[25:0] };
          end
          //jump_address <= jump_address << 2; 
        end
    end
endmodule
 
 // CONTROL DESIGN
 module Control(opcode,RegDst,Jump,Branch,MemRead,MemtoReg,ALUOp,MemWrite,ALUSrc,RegWrite);
  input [5:0] opcode;
  // Control Signals
  output reg [1:0] ALUOp;                            // 2 bit signal
  output reg RegDst,Jump,Branch,MemRead,MemtoReg,MemWrite,ALUSrc,RegWrite;  
  // Control Signals will be according to instruction ( depends on opcode ) //
  always@(*)
    begin
      // R type instruction //
      if (opcode == 0)                    
        begin
          RegDst <= 1;
          ALUSrc <= 0;
          MemtoReg <= 0;
          RegWrite <= 1;
          MemRead <= 0;
          MemWrite <= 0;
          Branch <= 0;
          Jump <= 0;
          // ALU Control
          ALUOp <= 2'b 10;               // it means funct field will be seen to determine instruction
        end
      // load word instruction //
      else if (opcode == 1)             // 1
        begin 
          RegDst <= 0;
          ALUSrc <= 1;
          MemtoReg <= 1;
          RegWrite <= 1;
          MemRead <= 1;
          MemWrite <= 0;
          Branch <= 0;
          Jump <= 0;
          // ALU Control
          ALUOp <= 2'b 00;               // always add 
        end
      // store word instruction //
      else if (opcode == 2)             // 2 
        begin 
          RegDst <= 1'b x;
          ALUSrc <= 1;
          MemtoReg <= 1'b x;
          RegWrite <= 0;
          MemRead <= 0;
          MemWrite <= 1;
          Branch <= 0;
          Jump <= 0;
          // ALU Control
          ALUOp <= 2'b 00;               // always add
        end
      // branch equal instruction //
      else if (opcode == 3)             // 3 
        begin 
          RegDst <= 1'b x;
          ALUSrc <= 0;
          MemtoReg <= 1'b x;
          RegWrite <= 0;
          MemRead <= 0;
          MemWrite <= 0;
          Branch <= 1;
          Jump <= 0;
          // ALU Control
          ALUOp <= 2'b 01;               // always subtract registers to compare and raise zero flag
        end
      //J type instruction //
      else if (opcode == 6'b 000100)             // 4
        begin
          RegDst <= 1'b x;
          ALUSrc <= 1'b x;
          MemtoReg <= 1'b x;
          RegWrite <= 1'b x;
          MemRead <= 1'b x;
          MemWrite <= 1'b x;
          Branch <= 0;
          Jump <= 1;
          // ALU Control
          ALUOp <= 2'b x;
        end
    end  
endmodule

// ALU CONTROL
module ALUControl(funct,ALUOp,ALUopcode);
  input[5:0] funct;
  input[1:0] ALUOp;
  output reg [3:0] ALUopcode;
  always@(*)
  begin
    if( ALUOp == 2'b 00)
      ALUopcode <= 4'b 0010;               //add
    else if(ALUOp == 2'b 01)
      ALUopcode <= 4'b 0110;               //subtract
    else if(ALUOp == 2'b 10)               //look funct field
      begin
        if( funct == 6'b 100000)
          ALUopcode <= 4'b 0010;           //add
        else if( funct == 6'b 100010)
          ALUopcode <= 4'b 0110;           //subtract
        else if( funct == 6'b 100100)
          ALUopcode <= 4'b 0000;           //AND
        else if( funct == 6'b 100101)
          ALUopcode <= 4'b 0001;           //OR
        else if( funct == 6'b 101010)
          ALUopcode <= 4'b 0111;           //set on less than
      end
  end
endmodule

// ALU DESIGN
// NOTE :
// This design only supports these instructions;
// add
// subtract
// or
// and
// shift left
module ALU(ALUopcode,Areg,Breg,shamt,ALU_out,Zero);
input [3:0] ALUopcode;
input [31:0] Areg,Breg;
input [4:0]  shamt;
output reg Zero;
output reg [31:0] ALU_out;

  always@(*)
  begin
      if (ALUopcode == 4'b 0010)
          ALU_out <= Areg + Breg;           	 //add//
      else if (ALUopcode == 4'b 0110)
        begin
          ALU_out <= Areg - Breg;            	//subtract//
          if (ALU_out == 32'b 0)
            Zero <= 1;
          else if (ALU_out != 32'b 0)
            Zero <= 0;
        end
      else if (ALUopcode == 4'b 0000)
          ALU_out <= Areg & Breg;           	 //bitwise AND//
      else if (ALUopcode == 4'b 0001)
          ALU_out <= Areg | Breg;           	 //bitwise OR//
      else if (ALUopcode == 4'b 0111)
          ALU_out <= Areg << shamt; 	      //shift left//
  end
endmodule

// Register File DESIGN
module RegFile(clk,ALUSrc,RegDst,RegWrite,Rs,Rt,Rd,rwrite_data,constant,Areg,Breg);
  input RegDst,RegWrite,clk,ALUSrc;
  input [4:0] Rs,Rt,Rd;
  input [31:0] rwrite_data,constant;
  output reg[31:0] Areg,Breg;
  reg [31:0] RegFile [9:0];           //base line of code for the creation of REGISTER FILE//
   initial                            //declaration of REGISTER FILE done at start//
   begin
    RegFile[0] = 32'b 0000_0000_0000_0000_0000_0000_0000_0000;
    RegFile[1] = 32'b 0000_0000_0000_0000_0000_0000_0000_0000;
    RegFile[2] = 32'b 0000_0000_0000_0000_0000_0000_0000_0000;
    RegFile[3] = 32'b 0000_0000_0000_0000_0000_0000_0000_0000;
    RegFile[4] = 32'b 0000_0000_0000_0000_0000_0000_0000_0000;
    RegFile[5] = 32'b 0000_0000_0000_0000_0000_0000_0000_0000;
    RegFile[6] = 32'b 0000_0000_0000_0000_0000_0000_0000_0000;
    RegFile[7] = 32'b 0000_0000_0000_0000_0000_0000_0000_0000;
    RegFile[8] = 32'b 0000_0000_0000_0000_0000_0000_0000_0000;
    RegFile[9] = 32'b 0000_0000_0000_0000_0000_0000_0000_0000;
   end
   
   // just register file reading // instructions : store word and branch equal and some part of R type
   always@(*)
   begin
        if (ALUSrc == 0)          // R type and beq
        begin
          Areg <= RegFile[Rs];
          Breg <= RegFile[Rt];
        end
        else if (ALUSrc == 1)    // lw and sw
        begin
          Breg <= constant;
          Areg [4:0] = Rs;
          Areg[31:5] = { Rs[4]? 27'b1:27'b0 ,Rs};
        end
   end
   
   // reg file write // instruction : load word and R type
   always@(posedge clk)
   begin
      if (RegWrite == 1)  //R type and lw
        begin
          if (RegDst == 0)  //lw
          begin
              RegFile[Rt] <= rwrite_data; 
          end
          else if (RegDst == 1) //R type
          begin
              RegFile[Rd] <= rwrite_data;
          end
        end
   end
   
endmodule

// RAM or Data Memory DESIGN
module RAM(clk,MemtoReg,MemRead,MemWrite,address,write_data,out);
  input clk,MemtoReg,MemRead,MemWrite;
  input [31:0] address,write_data;
  reg [31:0] read_data;
  output [31:0] out;
  
  reg[31:0]RAM[9:0];                     //base line of code for the creation of RAM//
  initial                               	//declaration of DATA MEMORY done at start//
  begin
    RAM[0]= 32'b 0000_0000_0000_0000_0000_0000_0000_0000;
    RAM[1]= 32'b 0000_0000_0000_0000_0000_0000_0000_0101;
    RAM[2]= 32'b 0000_0000_0000_0000_0000_0000_0000_0001;
    RAM[3]= 32'b 0000_0000_0000_0000_0000_0000_0000_0000;
    RAM[4]= 32'b 0000_0000_0000_0000_0000_0000_0000_0000;
    RAM[5]= 32'b 0000_0000_0000_0000_0000_0000_0000_0000;
    RAM[6]= 32'b 0000_0000_0000_0000_0000_0000_0000_0000;
    RAM[7]= 32'b 0000_0000_0000_0000_0000_0000_0000_0000;
    RAM[8]= 32'b 0000_0000_0000_0000_0000_0000_0000_0000;
    RAM[9]= 32'b 0000_0000_0000_0000_0000_0000_0000_0000;
  end
  always@(posedge clk)
    begin
      // memory write ( store word )
      if (MemWrite == 1)
        begin
          read_data <= 32'b x;
          RAM[address] <= write_data;
        end
    end
  always@(*)
    begin
      if (MemWrite == 0)
        begin
          // memory read
          read_data <= RAM[address];
        end
    end
    
    assign out = MemtoReg ? read_data : address;
    
endmodule