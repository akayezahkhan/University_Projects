module Decoder(
	 input clk,
    input [31:0] PC_out, //pc_out
    input [31:0] instruction,
    output reg [5:0] opcode,
    output reg [4:0] Rs,
    output reg [4:0] Rt,
    output reg [4:0] Rd,
    output reg [4:0] shamt,
    output reg [5:0] funct,
    output reg [31:0] constant,
    output reg [31:0] jump_address
    );
  // Instruction Slicing //
	always@(*)
		begin
			opcode <= instruction[31:26];    // first 6 bits (MSB) of instruction at (CPC) index are opcode
		end
		
	always@(*)
		begin
      //R type instruction slicing
      if (opcode == 6'b 000000)                         
        begin
          Rs <= instruction[25:21];
          Rt <= instruction[20:16];
          Rd <= instruction[15:11];
          shamt <= instruction[10:6];
          funct <= instruction[5:0];
			 constant <= 32'b x;
			 jump_address <= 32'b x;
        end
      //I type instruction slicing (beq)(lw)(sw)
      else if ((opcode == 6'b 000001) | (opcode == 6'b 000010) | (opcode == 6'b 000011))      
        begin
          Rs <= instruction[25:21];
          Rt <= instruction[20:16];
			 Rd <= 5'b x;
			 shamt <= 5'b x;
          funct <= 6'b x;
			 jump_address <= 32'b x;
          // MSB to be copied in constant to sign extend it
          if(instruction[15] == 1)
            begin
              constant <= { 16'b 1, instruction[15:0]};
            end  
          else if (instruction[15] == 0)
            begin
              constant <= { 16'b 0, instruction[15:0]};
            end
        end

      //J type instruction slicing
      else if (opcode == 6'b 000100)                          
        begin 
          Rs <= 5'b x;
          Rt <= 5'b x;
          Rd <= 5'b x;
          shamt <= 5'b x;
          funct <= 6'b x;
			 constant <= 32'b x;
          if (instruction[25] == 1)
          begin 
            jump_address <= {PC_out[31:28],1'b1,1'b1,instruction[25:0] };
          end
        else if (instruction[25] == 0)
          begin
            jump_address <= {PC_out[31:28],1'b0,1'b0,instruction[25:0] };
          end
        end
    end

endmodule