module Control(
input clk,
input rst,
input [5:0] opcode,
output reg RegDst,
output reg RegWrite,
output reg ALUSrcA,
output reg [1:0] ALUSrcB,
output reg [1:0] ALUOp,
output reg [1:0] PCSource,
output reg PCWriteCond,
output reg PCWrite,
output reg IorD,
output reg MemRead,
output reg MemWrite,
output reg MemtoReg,
output reg IRWrite
    );
	 
//fetch parameter
parameter FETCH = 5'b 00000;
parameter DECODE = 5'b 00001;
parameter MemAddrCalc = 5'b 00010;
parameter MEMAL = 5'b 00011;
parameter MEMR = 5'b 00100;
parameter MEMAS = 5'b 00101;
parameter EX = 5'b 00110;
parameter RTYPE = 5'b 00111;
parameter BRANCH = 5'b 01000;
parameter JUMP = 5'b 01001;


//state register
reg[4:0] state,nextstate;

	always@(posedge clk or posedge rst)
	begin
		if (rst == 1)
			state <= FETCH;
		else 
			state <= nextstate;
	end

//next state logic and control signals for every state
	always@(*)
	begin
		case(state)
		FETCH :
			begin
				MemRead = 1;
				ALUSrcA = 0;
				IorD = 0;
				IRWrite = 1;
				ALUSrcB = 2'b01;
				ALUOp = 2'b00;
				PCWrite = 1;
				PCSource = 2'b00;
				//next state will always be decode after fetch
				nextstate <= DECODE;
			end

		DECODE :
			begin
			//control signals
			PCWrite = 0;
			MemRead = 0;
			
			ALUSrcA = 0;
			ALUSrcB = 2'b11;
			ALUOp = 2'b00;
			//IRWrite = 0;
			//for next state
				if (opcode == 6'd0)	//r type
					nextstate <= EX;
				else if (opcode == 6'd1)	//lw
					nextstate <= MemAddrCalc;
				else if (opcode == 6'd2)	//sw
					nextstate <= MemAddrCalc;
				else if (opcode == 6'd3)	//beq
					nextstate <= BRANCH;
				else if (opcode == 6'b 000100)	//jump
					nextstate <= JUMP;
				else
					nextstate <= FETCH;
			end

		MemAddrCalc:
			begin
				//control signals
				PCWrite = 0;
				ALUSrcA = 1;
				ALUSrcB = 2'b10;
				ALUOp = 2'b00;
				//next state
				if (opcode == 6'd1)	//lw
					nextstate = MEMAL;
				else if (opcode == 6'd2)	//sw
					nextstate = MEMAS;
				else
					nextstate <= FETCH;
			end

		EX :
			begin
			//control signals
			PCWrite = 0;
			ALUSrcA = 1;
			ALUSrcB = 2'b00;
			ALUOp = 2'b10;
			//next state
			nextstate <= RTYPE;
			end
		
		BRANCH :
			begin
			//control signals
			PCWrite = 0;
			ALUSrcA = 1;
			ALUSrcB = 2'b00;
			ALUOp = 2'b01;
			PCWriteCond = 1;
			PCSource = 2'b01;
			//next state
			nextstate <= FETCH;
			end
		JUMP :
			begin
			//control signals
			PCWrite = 1;
			PCSource = 2'b10;
			//next state
			nextstate <= FETCH;
			end
		RTYPE :
			begin
			//control signals
			RegDst = 1;
			RegWrite = 1;
			MemtoReg = 0;
			//next state
			nextstate <= FETCH;
			end
		MEMAL :
			begin
			//control signals
			PCWrite = 0;
			MemRead = 1;
			IorD = 1;
			//next state
			nextstate <= MEMR;
			end
		MEMAS :
			begin
			//control signals
			PCWrite = 0;
			MemWrite = 1;
			IorD = 1;
			//next state
			nextstate <= FETCH;
			end
		MEMR :
			begin
			//control signals
			PCWrite = 0;		
			RegDst = 1;
			RegWrite = 1;
			MemtoReg = 1;
			//next state
			nextstate <= FETCH;
			end

		default : //condition for FETCH
				begin
				MemRead = 1;
				ALUSrcA = 0;
				IorD = 0;
				IRWrite = 1;
				ALUSrcB = 2'b01;
				ALUOp = 2'b00;
				PCWrite = 1;
				PCSource = 2'b00;
				//next state will always be decode after fetch
				nextstate <= DECODE;
				end
		endcase
	end

endmodule