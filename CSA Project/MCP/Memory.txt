module Memory(					//Data memory + Instruction memory
	input clk,
	input IorD,
	input [31:0]ALU_out,
	input [31:0]PC_out,
	input MemRead,
	input MemWrite,
	input [31:0] write_data,
	output reg [31:0] MemData
    );
	
	wire [31:0] Address;
	assign Address = IorD ? ALU_out : PC_out;
	
	//assynchronous read
	always@(*)
		begin
			if ((MemRead == 1)&&(IorD == 0))			// FETCH
			begin
				MemData <= mem[Address];
			end
			else if((MemRead == 1)&&(IorD == 1))	// MEMAL
			begin
				MemData <= mem[Address+8];
			end

		end
	
	//synchronous write
	always@(posedge clk)
	begin
		if((MemWrite == 1)&&(IorD == 1))	// MEMAS
		begin
			mem[Address+8] <= write_data;
		end
	end
	
	//change into one mem
	//add offset(8) everytime we want to access data from RAM
	
	reg [31:0]mem[19:0];                  //base line of code for the creation of ROM//
	initial                               //declaration of INSTRUCTION MEMORY done at start//
		begin

			//           opcode rs    rt    offset
			mem[0]= 32'b 000001_00000_00000_0000000000000000;              //opcode for lw
			mem[1]= 32'b 000001_00000_00001_0000000000000001;
			mem[2]= 32'b 000001_00000_00010_0000000000000010;
			//           opcode rs    rt    rd    shamt funct
			mem[3]= 32'b 000000_00010_00000_00000_00000_100000;            //opcode for R type ( funct field == add )
			//           opcode rs    rt    constant
			mem[4]= 32'b 000011_00000_00001_0000000000000001;              //opcode for beq
			//           opcode jump_address
			mem[5]= 32'b 000100_00000000000000000000000011;                //opcode for jump
			//           opcode rs    rt    offset
			mem[6]= 32'b 000010_00000_00000_0000000000000011;              //opcode for sw
			//last line of code (this will execute an infinite loop
			//           opcode jump_address
			mem[7]= 32'b 000100_00000000000000000000000111;                //opcode for jump
		


//			//           opcode rs    rt    rd    shamt funct
//			mem[0]= 32'b 000000_00000_00001_00010_00000_100000;            //opcode for r type
//			//           opcode rs    rt    offset
//			mem[1]= 32'b 000010_00000_00010_0000000000000000;              //opcode for sw
//			//           opcode rs    rt    offset
//			mem[2]= 32'b 000001_00000_00000_0000000000000011;              //opcode for lw
//
//			mem[3]= 32'b 0;
//			mem[4]= 32'b 0;
//			mem[5]= 32'b 0;
//			mem[6]= 32'b 0;
//			mem[7]= 32'b 0;

		//DATA MEMORY after 8 locations
		
			mem[8]  = 32'd5;
			mem[9]  = 32'd0;
			mem[10] = 32'd0;
			mem[11] = 32'd0;
			mem[12] = 32'd0;
			mem[13] = 32'd0;
			mem[14] = 32'd0;
			mem[15] = 32'd0;
			mem[16] = 32'd0;
			mem[17] = 32'd0;
			mem[18] = 32'd0;
			mem[19] = 32'd0;
			
		end

endmodule